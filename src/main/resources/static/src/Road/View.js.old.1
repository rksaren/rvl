import React, { Fragment, PureComponent } from "react";
import ImageViewer from "../ImageViewer";
import Slider from "../Slider";
import DetectionView from "../Table";
import PropTypes from "prop-types";
import settings from "../settings"
import update from "immutability-helper"
import $ from "jquery";
import SideBar from "../SideBar"
import { withRouter,Link } from 'react-router-dom';
import {getImage} from "../helper"
import * as d3 from "d3";
import { Provider, withBus } from 'react-bus'
import Map from "../Map"
import Materialize from "materialize-css"
import KendoGrid from "../KendoGrid"
import ColumnMenu from "../ColumnMenu"
import {  GridColumn as Column } from '@progress/kendo-react-grid'
import ReactExport from "react-data-export";

const ExcelFile = ReactExport.ExcelFile;
const ExcelSheet = ReactExport.ExcelFile.ExcelSheet;
const ExcelColumn = ReactExport.ExcelFile.ExcelColumn;

const Download = (props)=> {

        return (
            <ExcelFile element={<i style={{fontSize:"20px",cursor:"pointer"}} className="fa fa-cloud-download"   title="Download Excel" ></i>}>
                <ExcelSheet data={props.data} name="Detections">
                  <ExcelColumn  label={"Feature name"} value={"name"}     />
                  <ExcelColumn   label={"Milepoint"}  value={"mile"}   />
                  <ExcelColumn   label={"Latitude"}  value={"lat"}    />
                  <ExcelColumn   label={"Longitude"}  value={"lon"}     />
                  <ExcelColumn   label={"Confidence"}  value={"confidence"} />
                  <ExcelColumn   label={"Collected on"} value={"created"}    />

                </ExcelSheet>
            </ExcelFile>
        )

}
class FullGrid extends PureComponent{

  constructor(props) {

    super(props)
    this.gridopts = {
      take:10,skip:0,
      sort: [
            { field: 'mile', dir: 'asc' }
        ]
    }
 }
 render(){
   return  (
      <KendoGrid data={this.props.processed}
           initstate={ this.gridopts} scrollable={"none"}
           style={{ height: '624px',width:"1000px" }} >
           <Column width={"200px"} title={"Feature name"} field={"name"} columnMenu={ColumnMenu}   />
           <Column width={"150px"} title={"Milepoint"}  field={"mile"}  columnMenu={ColumnMenu} filter="numeric"  />
           <Column width={"150px"} title={"Latitude"}  field={"lat"}  columnMenu={ColumnMenu} filter="numeric"  />
           <Column width={"150px"} title={"Longitude"}  field={"lon"}  columnMenu={ColumnMenu} filter="numeric"  />
           <Column width={"150px"} title={"Confidence"}  field={"info.confidence"}  columnMenu={ColumnMenu} filter="numeric"  />
           <Column width={"200px"} title={"Collected on"} field={"created"} columnMenu={ColumnMenu} filter="date"  />

       </KendoGrid>
     )
 }
 componentDidUpdate(){
   console.log("updated")
 }
}
class RoadView extends PureComponent {

  constructor(props) {

    super(props)
    this.state = {
      isLoading: true,playing:false,
      job: null,curr:0,items:null,mappings:null,fullgrid:false
    }
    //this.items = this.state.item
    //this.mappings = this.state.mappings
    this.dataMissing = null
    this.getMappings.bind(this)
  }

  render() {

    if (this.state.isLoading) {

      return (<div className="lds-facebook">
        <div></div>
        <div></div>
        <div></div>
      </div>)

    } else if (this.state.items == null || this.state.items.length == 0) {
      return (
        <React.Fragment>
          <Link to={"/Roads"}><span className={"back"}  >Back</span></Link>
          <div className={"row"}>
            <div className="col s10"><h5>Images for Road #{this.props.param.id}</h5></div>

            <div className={"col s2"}>{this.getJobRunning()} </div>

          </div>
        <div className="noresults">No Images found..</div>
        </React.Fragment>
      )
    }

    return (
      <React.Fragment>
        <Link to={"/Roads"}> <span className={"back"}  >Back</span></Link>
        <SideBar isroad={Number(this.props.param.id)} item={this.workspace} playing={this.state.playing}  play={this.autoPlay.bind(this)}
        next={this.next.bind(this)} prev={this.prev.bind(this)}/>
        <div className={"row"}>
          <div className="col s8"><h5>Images for road  #{this.props.param.id}</h5></div>
          <div className={"col s2"}      style={{padding: "12px"}} >
               <i style={{fontSize:"20px",cursor:"pointer",color:this.state.fullgrid ? "BLACK" : "#C2C2C2" }}
                            className="fa fa-television"   title="Full Grid"
                      onClick={this.showFullGrid.bind(this)}></i>
               &nbsp;&nbsp;
               {this.getDownload()}
          </div>
          <div className={"col s2"}>{this.getJobRunning()} </div>

        </div>
        <div className="row">
        <span>Milepoint &nbsp; &nbsp;{ this.state.items[this.state.curr]} </span>
        </div>
        <div className={"row nopadding"} >
          {this.getImageViewer()}
        </div>
        {
          this.state.items.length > 1 ?
          (<div className={"row"} style={{ marginTop: "10px" }}>
            <Slider curr={this.state.curr} changeState={this.slide.bind(this)} param={this.getSlideParam()}/>
          </div>) : (<Fragment></Fragment>)

        }
        {
          this.state.job != null ?
            (
               <div className={"row nopadding"}> {this.getDetectionView()} </div>

            )
            : (<Fragment></Fragment>)
        }
      </React.Fragment>
    )
  }
  getMap(){
    let data = this.state.items.map( (x) => { 
        let q = this.state.mappings[x]
        q = typeof q.Left == "undefined" ? q.left : q.Left
	return { lat: q.lat,lon:q.lon,mile:x  }})
    if(data.length == 0) return (<Fragment></Fragment>)

    return (  <Map data={data} curr={this.state.curr} ></Map>)
  }
  getJobRunning(){
    let self = this
    if(this.state.job != null){
      let job = this.jobs.find((t)=>{ return t.id == self.state.job } )
      if(job.status == 2){
      return ( <div className={"lds-facebook"}>
        <div></div>
        <div></div>
        <div></div>
      </div> )
    }else {
        return this.getJobDropdown()
    }}
    return (<Fragment></Fragment>)
  }
  showFullGrid(){
    this.setState(update( this.state,{fullgrid:{$set:!this.state.fullgrid}}))
  }
  getDownload(){
    let self = this
    let items = this.state.items

    let processed = items.reduce((total,curr) =>{
      let images = self.state.mappings[curr]
      let currtotal =  Object.keys( images).reduce((t,c)=>{
        let hasResult = images[c].processed.filter((d)=>{  return d.job == self.state.job })
        return t.concat(hasResult.map((f)=>{
          return  {lat:images[c].lat,lon:images[c].lon,mile:curr,confidence:f.info.confidence,name:f.name,created:f.created}
        })) },[] )
      return total.concat(currtotal)
    }  ,[] )

    return (<Download data={processed} ></Download> )
  }
  next(){
    let idx = this.state.curr
    if(idx + 1 < this.state.items.length){

    let s = update( this.state,{curr:{$set:(idx +1)}} )

    this.setState(s)
    }
  }
  prev(){
    let idx = this.state.curr
    if(idx - 1 >= 0){

      let s = update( this.state,{curr:{$set:(idx -1 )}} )

      this.setState(s)
    }
  }
  sortImages(a,b){
    if(isNaN(a) && isNaN(b)){
      let transform = (z)=>{
        let q = z.toLowerCase()
        if(q == "left" || q.includes("left") || q.startsWith("l"))
          return 0
        else if(q == "right" || q.includes("right") || q.startsWith("r") )
          return 2
        else return 1
      }
      return transform(a) - transform(b)
    }else {
      return a - b
    }
  }
  getItem( ){
    return this.state.mappings[this.state.items[this.state.curr]]
  }

  slide(curr){
      let n =  Math.ceil( curr  )

      let s = update( this.state,{curr:{$set:n}} )

      this.setState(s)
  }
  getDetectionView() {
    let self = this


    if(!this.state.fullgrid)
    {
      let images = this.getItem()
      let processed = Object.keys( images)
          .reduce((total,curr)=>{ return total.concat(images[curr].processed) },[] )

      let job = this.jobs.find( (f)=>{ return f.id == self.state.job})
      let features = job.param.features
      processed = processed.filter( (q)=>{ return q.job == self.state.job &&
          typeof  features.find((z)=>{ return z.label == q.name
              && z.threshold <= Number(q.info.confidence)*100  }) != "undefined" } )

      return (<DetectionView   items={processed}>{this.getMap()}</DetectionView> );
    }

    else
    {

      let items = this.state.items.filter((x,idx)=> { return idx <= this.state.curr })
      let processed = items.reduce((total,curr) =>{
        let images = self.state.mappings[curr]
        let currtotal =  Object.keys( images).reduce((t,c)=>{
          let hasResult = images[c].processed.filter((d)=>{  return d.job == self.state.job })
          return t.concat(hasResult.map((f)=>{
            return Object.assign(f,{lat:images[c].lat,
		lon:images[c].lon,mile:curr})
          })) },[] )
        return total.concat(currtotal)
      }  ,[] )

      return ( <FullGrid key={processed.length} processed={processed}></FullGrid>

       )
    }
  }
  autoPlay(){
    let self = this
    let checked = this.state.playing;

    if(!checked){


        this.timer = d3.interval(()=> {
          let loading = 0
          document.querySelectorAll("img").forEach((x,y)=>{ loading += x.complete ? 0 :1    } )
          if( loading > 0) return
          let idx =  self.state.curr
          if(idx +1 < self.state.items.length )
          self.setState(update(self.state, {curr: {$set:idx+1} }))
          else{
            self.timer.stop()
            delete self.timer
            self.setState(update(self.state,{playing:{$set:false}}))
          }
        },3000);
      this.setState(update(this.state,{playing:{$set:true}}))
    }else{

      this.timer.stop()
      delete this.timer
      this.setState(update(this.state,{playing:{$set:false}}))
    }
  }
  initMaterial(){
    let elems = document.getElementById('jobselect')
    Materialize.FormSelect.init(elems, {})
  }
  handleSelect = (e) => {
    let newstate = update(this.state,{ job:{$set : e.currentTarget.value}})
    this.setState(newstate)
  }
  getJobDropdown(){
    if(!settings.showjobdropdown)
      return (<Fragment></Fragment>)

    return (
      <select   defaultValue={this.state.job}  id="jobselect" onChange={this.handleSelect.bind(this)}>

        { this.jobs.map( (d,i)=>(
          <option value={d.id} key={d.id}  >{d.param.features.length == 1 ? d.param.features[0].label : d.param.features.length+" features" }</option>
        ) ) }
      </select>
    )
  }
  getImageViewer() {
    let self = this
    let images = this.getItem()
    images =  Object.keys(images).sort(this.sortImages)
      .map((dir)=>{
      let image = images[dir]
      let old = image.path
      let newItems = image.processed
      let isProcessed = this.state.job != null
      let hasResult = newItems.filter((d)=>{  return d.job == self.state.job })
      if(!settings.showjobdropdown && hasResult.length == 0 && isProcessed  && newItems.length > 0 ){
        hasResult = [newItems.sort((a,b)=>{ return b.job - a.job } )[0]]
      }

      return { curr: isProcessed && hasResult.length != 0?   hasResult[0].info.imagepath : old,
          old:old,type:isProcessed && hasResult.length != 0?   "curr" : "old"}

    })

    images = Object.keys(images).map( (dir,idx) => (


      <  ImageViewer  key={dir+"_"+idx}    height={"400px"} src={getImage(images[dir])}/>
    ))

    console.log(images)
    return images;
  }

  getSlideParam() {
    let width = document.querySelector(".app_content").clientWidth

    return  {


      width:width,height:20,start:0,
      end:this.state.items.length-1 ,
      count:this.state.items.length
    }
  }
  loadData(){
    let id = this.props.param.id
    let self = this

    $.ajax({
      url: settings.baseurl + "/io/getroadimages/?road=" + id , type: "GET"
    }).done((images)=>{
      if(images.length == 0){

        self.setState(update(self.state,{ isLoading:{$set:false}}))
        return false
      }
      let {mappings,items,dataMissing} = self.getMappings(images)
      //self.mappings = mappings
     // self.items = items

      self.dataMissing = dataMissing

      let workspace_id = images[0].workspace

        let d0 = $.ajax({
            url: settings.baseurl + "/data/workspaces/" + workspace_id+"/", type: "GET"
          })
          let d1 = $.ajax({
            url: settings.baseurl + "/data/jobs/?workspace=" + workspace_id, type: "GET"
          })
        $.when(d0, d1 ).done((v0, v1 ) => {
            self.workspace = v0[0]
            self.jobs = v1[0].filter( (t)=> { return t.type==5 || t.type == 7})
				.sort( (p,q) => { return p.id - q.id })


            let job = self.jobs.length > 0 ? self.jobs[self.jobs.length - 1].id : null
            let s = update(self.state,{
              mappings:{$set:mappings},
	            items:{$set:items},
              job:{$set:job},isLoading:{$set:false}
            })
            self.setState(s)
        })
    })
  }
  componentDidMount() {
    let self = this
    this.props.bus.on("job-update",(job)=>{
	if( job.id == self.state.job || job.status==1 && job.road == this.props.param.id)
		self.loadData()} ) //this.loadData.bind(this))
    this.loadData()

  }
  componentDidUpdate(prevProps, prevState, snapshot) {
    this.initMaterial()

  }
  componentWillUnmount(){
    this.props.bus.off("job-update")
  }
  getMappings (images){
    let dataMissing = true
     let getName = (p)=>{
        let aname = p.path.split("/")
        return  aname[aname.length -1].split(".")[0] }
    let getMile = (p)=>{ return p.roadinfo.milepoint }

    let mappings = images.reduce( (total,currentValue)=>{
        let key = getMile(currentValue)
        if(typeof  key == "undefined")
          key = getName(currentValue)

        let found = total[key]
        if(typeof found == "undefined"){
          found = {}
          total[key] = found

        }
        let dir = currentValue.roadinfo.direction

        let count = Object.keys(found).length
        if(typeof dir != "undefined")
          found[dir] = currentValue
        else found[count] = currentValue

        return total
    },{})
    if(Object.keys(mappings).length > Math.ceil(images.length/2))
    {
      mappings = images.reduce((total,current,idx,arr)=>{

        if(idx%3 == 0){
          total.push([current ] )

        }else{
          total[total.length -1].push(current)
        }

        return total
      },[] )

    }
    else if(isNaN(Object.keys(mappings)[0]))
    {
         mappings = Object.keys(mappings).map( (q)=>{ return mappings[q] })
    }
    else dataMissing = false
    let items = Object.keys(mappings).map((z)=>{return Number(z)})
          .sort((a, b)=>{
         return a-b
    })

    return {items:items,mappings:mappings,dataMissing }
  }
}
RoadView.propTypes = {
  changeState: PropTypes.func,
  param:PropTypes.object
};
let returnObj = RoadView
returnObj = withBus()( returnObj )
export default withRouter(returnObj);

